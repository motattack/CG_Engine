class Cumera {
public:
    Vec3 pos;
    Vec3 direction = Vec3(0.0f, 0.0f, -1.0f);
    Vec3 up = Vec3(0.0f, 1.0f, 0.0f);
    Vec3 right;
    sf::Vector2i prevPos;
    sf::Vector2i curPos;
    float w;
    float h;

    bool firstClick = true;

    float speed = 0.1f;
    float sens = 5.0f;
    float pitch = -0.0f;
    float yaw = 90.0f;

    Cumera(float width, float height, Vec3 pos1) {
        pos = pos1;
        w = width;
        h = height;
    }

    void look(float fov, float nearPlane, float farPlane, int shaderId, const char* uniform) {


        //glUniformMatrix4fv(glGetUniformLocation(shaderId, uniform), 1, GL_FALSE, &matPV.matrix[0][0]);

        Mat4 matPV = Perspective(45.0f, static_cast<float>(w / h), 0.1f, 100.0f) * LookAt(pos, pos + direction, up);
        Mat4 model = matPV.E();

        glUniformMatrix4fv(glGetUniformLocation(shaderId, "model"), 1, GL_FALSE, &(model).matrix[0][0]);
        glUniformMatrix4fv(glGetUniformLocation(shaderId, "matPV"), 1, GL_FALSE, &(matPV).matrix[0][0]);
    }

    void move(bool* isGo, sf::RenderWindow &window) {
        sf::Event windowEvent;

        /*direction.x = cos(-89.0f * rad) * cos(0.0f * rad);
        direction.y = sin(0.0f * rad);
        direction.z = sin(-89.0f * rad) * cos(0.0f * rad);*/
        Vec3 right = CrossProduct(direction, Vec3(0, 1, 0)).Normalize();
        up = CrossProduct(right, direction).Normalize();
        while (window.pollEvent(windowEvent)) { // обработка ивентов
            //ImGui::SFML::ProcessEvent(windowEvent);
            switch (windowEvent.type)
            {
                case sf::Event::Closed:
                    *isGo = false;
                    break;
                case sf::Event::KeyPressed: {
                    if (windowEvent.key.code == sf::Keyboard::W) {
                        pos += direction * (speed);
                        cout << "press W\n";
                    }
                    if (windowEvent.key.code == sf::Keyboard::S) {
                        cout << "press S\n";
                        pos -= direction * (speed);
                    }
                    if (windowEvent.key.code == sf::Keyboard::D) {
                        cout << "press D\n";
                        pos += CrossProduct(direction, up).Normalize() * (speed);
                    }
                    if (windowEvent.key.code == sf::Keyboard::A) {
                        cout << "press A\n";
                        pos -= CrossProduct(direction, up).Normalize() * (speed);
                    }
                    if (windowEvent.key.code == sf::Keyboard::Space) {
                        cout << "press Sp\n";
                        pos += up * (speed);
                    }
                    if (windowEvent.key.code == sf::Keyboard::X) {
                        cout << "press X\n";
                        pos -= up * (speed);
                    }
                    if (windowEvent.key.code == sf::Keyboard::LShift) {
                        cout << "press LS\n";
                        speed = 0.4f;
                    }
                    break;
                }
                default:
                    break;
            }

            if (windowEvent.type == sf::Event::MouseMoved) {
                curPos = sf::Mouse::getPosition(window);

                if (firstClick) {
                    firstClick = false;
                    prevPos = curPos;
                }

                yaw += speed * (float)(curPos.x - prevPos.x);//sens * (float)(curPos.y - (h / 2)) / h;
                pitch += speed * (float)(prevPos.y - curPos.y);//sens * (float)(curPos.x - (w / 2)) / w;

                prevPos = curPos;

                if (pitch >= 89.0f) {
                    pitch = 89.0f;
                }
                if (pitch <= -89.0f) {
                    pitch = -89.0f;
                }

                direction.x = cos(rad * yaw) * cos(rad * pitch);
                direction.y = sin(rad * pitch);
                direction.z = sin(rad * yaw) * cos(rad * pitch);

                direction = direction.Normalize();
                up = CrossProduct(CrossProduct(direction, Vec3(0.0f, 1.0f, 0.0f)).Normalize(), direction).Normalize();
                /*direction = QRotation(direction, CrossProduct(direction, up), -rotX).Normalize();
                up = CrossProduct(CrossProduct(direction, Vec3(0.0f, 1.0f, 0.0f)), direction).Normalize();




                direction = QRotation(direction, up, -rotY);*/
                //sf::Mouse::setPosition(sf::Vector2i(800 / 2, 600 / 2), window);
            }
            else if (sf::Event::MouseButtonReleased) {
                if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {
                    firstClick = true;
                }
            }
            //if (1/*sf::Event::MouseButtonPressed*/) {
            //	if (1/*sf::Mouse::isButtonPressed(sf::Mouse::Left)*/) {


            //		if (firstClick) {
            //			firstClick = false;
            //		}

            //		prevPos = curPos;
            //		curPos = sf::Mouse::getPosition(window);

            //		float rotX = curPos.x - prevPos.x;//sens * (float)(curPos.y - (h / 2)) / h;
            //		float rotY = curPos.y - prevPos.y;//sens * (float)(curPos.x - (w / 2)) / w;
            //		//float rotY = curPos.x - prevPos.x;

            //		Vec3 newDirection = QRotation(direction, CrossProduct(direction, up), -rotX);

            //		if (abs(angle(newDirection, up) - rad * (90.0f)) <= rad * 85.0f)
            //		{
            //			direction = newDirection;
            //		}

            //		direction = QRotation(direction, up, -rotY);

            //	}
            //}
            /*		else if (sf::Event::MouseButtonReleased) {
                        if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {
                            firstClick = true;
                        }
                    }

                    */
            //pos += direction;
            //cout << angle();
            //direction = QRotation(direction, CrossProduct(direction, up).Normalize(), -rotX);
            //direction = glm::rotate(direction,  glm::radians( - rotY), up);



        }

        //cout << pos<<'\n';
    }
};